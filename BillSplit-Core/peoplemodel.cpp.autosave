#include "peoplemodel.h"
#include <QJsonArray>
#include <QJsonObject>
#include <QMessageBox>      // This requires widgets, see if there is another way to do this
#include <QGuiApplication>
#include <QtGlobal>

PeopleModel::PeopleModel(DataCore& dataCore, QObject* parent) :
    QAbstractTableModel(parent),
    m_data(dataCore),
    m_columnWidths(Sections::COUNT)
{
}

int PeopleModel::rowCount(const QModelIndex& parent) const
{
    return parent.isValid() ? 0 : m_data.NumPeople();
}

int PeopleModel::columnCount(const QModelIndex& parent) const
{
    return parent.isValid() ? 0 : Sections::COUNT;
}

QVariant PeopleModel::data(const QModelIndex& index, int role) const
{
    if (isIndexValid(index))
    {
        auto person = m_data.GetPersonByIndex(index.row());

        switch (role)
        {
            case Qt::DisplayRole:
            {
                switch (index.column())
                {
                    case Sections::Initials: return person.initials;
                    case Sections::Name: return person.name;
                }
                break;
            }
            case Roles::IdRole: return person.id;
            case Roles::InitialsRole: return person.initials;
            case Roles::NameRole: return person.name;
        }
    }

    return QVariant();
}

// TODO: Is this really the best way to do this, recursion?  Maybe we need an overload
// The use of roles like this is really not as the model was intended.  Perhaps we
// Should instead have a different method that can be called directly.  EditRoles?

bool PeopleModel::setData(const QModelIndex& index, const QVariant& value, int role)
{
    if (!isIndexValid(index)) {
        return false;
    }

    if (role == Qt::EditRole) {
        switch(index.column()) {
            case Sections::Initials: return setData(index, value, Roles::InitialsRole);
            case Sections::Name: return setData(index, value, Roles::NameRole);
        }

    } else if (role == Roles::InitialsRole || role == Roles::NameRole) {
        Person personCopy(m_data.GetPersonByIndex(index.row()));

        switch (role) {
            case Roles::InitialsRole: personCopy.initials = value.toString(); break;
            case Roles::NameRole: personCopy.name = value.toString(); break;
        }

        if (m_data.EditPerson(index.row(), personCopy)) {
            emit dataChanged(index, index);
            return true;
        } else {
            if (role == Roles::InitialsRole) {
                QMessageBox msg;
                msg.setText("Initials must be unique");
                msg.exec();
            }
        }
    }

    return false;
}

bool PeopleModel::removeRows(int row, int count, const QModelIndex& parent)
{
    if (parent.isValid()) {
        return false;
    }

    beginRemoveRows(parent, row, row + count - 1);
    bool result = m_data.DeletePeople(row, count);
    endRemoveRows();
    return result;
}

QVariant PeopleModel::headerData(int section, Qt::Orientation orientation, int role) const
{
    if (orientation == Qt::Orientation::Horizontal && role == Qt::DisplayRole) {
        switch(section) {
            case Sections::Initials: return "Initials";
            case Sections::Name: return "Name";
        }
    }

    return QAbstractItemModel::headerData(section, orientation, role);
}

Qt::ItemFlags PeopleModel::flags(const QModelIndex& index) const
{
    // TODO: I don't understand the purpose of this return variable.
    if (!index.isValid())
        return Qt::ItemIsEnabled;

    return QAbstractItemModel::flags(index) | Qt::ItemIsEditable;
}

QHash<int, QByteArray> PeopleModel::roleNames() const
{
    QHash<int, QByteArray> roles = QAbstractTableModel::roleNames();
    roles[Roles::InitialsRole] = "initials";
    roles[Roles::NameRole] = "name";
    return roles;
}

bool PeopleModel::addPerson(QString initials, QString name)
{
    beginInsertRows(QModelIndex(), rowCount(), rowCount());
    bool result = m_data.AddPerson({std::move(initials), std::move(name)});
    endInsertRows();
    return result;
}

// TODO: Resize on value change
int PeopleModel::columnWidth(int c, const QFont* font)
{
    Q_UNUSED(font);
    
    if (c < 0 || c >= Sections::COUNT) {
        return 0;
    }

    if (!m_columnWidths[c]) {

        // The font is always passed as nullptr, so I am hacking past this
        QFont hackFont;
        hackFont.setPointSize(15);    
//        QFontMetrics defaultFontMetrics = QFontMetrics(QGuiApplication::font());
//        QFontMetrics fm = (font ? QFontMetrics(*font) : defaultFontMetrics);

        QFontMetrics fm(hackFont);
        int ret = fm.horizontalAdvance(headerData(c, Qt::Horizontal).toString() + QLatin1String(" ^")) + 8;

        for (int r = 0; r < rowCount(); ++r) {
            ret = qMax(ret, fm.horizontalAdvance(data(index(r,c), Qt::DisplayRole).toString()));
        }

        m_columnWidths[c] = ret;
    }

    return m_columnWidths[c];
}

void PeopleModel::jsonRead(const QJsonObject& json)
{
    beginRemoveRows(QModelIndex(), 0, m_data.NumPeople() - 1);
    m_data.ClearPeople();
    endRemoveRows();

    QJsonArray peopleArray = json["people"].toArray();
    beginInsertRows(QModelIndex(), 0, peopleArray.count() - 1);
    for (const auto& element : peopleArray)
    {
        QJsonObject personObj = element.toObject();
        m_data.AddPerson({personObj["initials"].toString(), personObj["name"].toString()});
    }
    endInsertRows();
}

void PeopleModel::jsonWrite(QJsonObject& json) const
{
    QJsonArray peopleArray;
    for(int i = 0; i < m_data.NumPeople(); ++i)
    {
        QJsonObject curr;
        curr["initials"] = m_data.GetPersonByIndex(i).initials;
        curr["name"] = m_data.GetPersonByIndex(i).name;
        peopleArray.append(curr);
    }
    json["people"] = peopleArray;
}

bool PeopleModel::isIndexValid(const QModelIndex& index) const
{
    return index.isValid() && index.row() < rowCount() && index.column() < columnCount();
}
